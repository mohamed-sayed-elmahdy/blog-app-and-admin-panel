[
  {
    "id": "1",
    "type": {
      "en": "theoretical",
      "ar": "Ù†Ø¸Ø±ÙŠ"
    },
    "difficulty": {
      "en": "easy",
      "ar": "Ø³Ù‡Ù„"
    },
    "categories": [
      {
        "en": "JavaScript",
        "ar": "Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª"
      }
    ],
    "tags": [
      {
        "en": "function declaration, function expression",
        "ar": "function declaration, function expression"
      }
    ],
    "question": {
      "en": "What is the difference between function declaration and function expression?",
      "ar": "Ù…Ø§ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† function declaration Ùˆ function expressionØŸ"
    },
    "codeSnippetQuestion": {
      "code": "",
      "lang": "javascript"
    },
    "examples": [],
    "media": {
      "image": "",
      "video": "",
      "audio": ""
    },
    "optionsForMcq": [
      {
        "id": "",
        "text": {
          "en": "",
          "ar": ""
        },
        "isCorrect": false,
        "feedback": {
          "en": "",
          "ar": ""
        }
      }
    ],
    "answer": {
      "en": "\n\n**Answer:**\n\nA **function declaration** is a function defined using the `function` keyword followed by its name. A function declaration can be called even before it appears in its scope because it is **hoisted**.\n\nExample:\n\n```js\nsayHello(); // âœ… works, because of hoisting\n\nfunction sayHello() {\n  console.log(\"Hello from a function declaration!\");\n}\n```\n\nA **function expression**, on the other hand, is a function assigned as a value to a variable. It can be **anonymous** or **named**. Named function expressions are useful for recursion or debugging. Unlike function declarations, function expressions are **not hoisted**, so they cannot be called before they are defined.\n\nExample:\n\n```js\nsayHello(); // âŒ Error: Cannot access 'sayHello' before initialization\n\nconst sayHello = function() {\n  console.log(\"Hello from a function expression!\");\n};\n```\n\nğŸ‘‰ **Key differences:**\n\n* **Hoisting:** Function declarations are hoisted, function expressions are not.\n* **Readability:** Declarations make code more structured when functions are used in multiple places.\n* **Flexibility:** Expressions are more flexible since they can be passed as arguments (e.g., callbacks) or stored in data structures.\n\n",
      "ar": "\n\n**Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©:**\n\nØ§Ù„Ù€ **function declaration** Ù‡Ùˆ ØªØ¹Ø±ÙŠÙ Ø¯Ø§Ù„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙ„Ù…Ø© `function` Ù…ØªØ¨ÙˆØ¹ Ø¨Ø§Ø³Ù…Ù‡Ø§. Ø§Ù„Ù€ function declaration Ù…Ù…ÙƒÙ† ØªØ³ØªØ¯Ø¹ÙŠÙ‡ Ø­ØªÙ‰ Ù‚Ø¨Ù„ Ù…Ø§ ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ù€ scope Ø¨ØªØ§Ø¹Ù‡ Ù„Ø£Ù†Ù‡ Ø¨ÙŠØªÙ… **hoisting**.\n\nÙ…Ø«Ø§Ù„:\n\n```js\nsayHello(); // âœ… Ø´ØºØ§Ù„ Ø¨Ø³Ø¨Ø¨ hoisting\n\nfunction sayHello() {\n  console.log(\"Hello from a function declaration!\");\n}\n```\n\nØ£Ù…Ø§ Ø§Ù„Ù€ **function expression** ÙÙ‡Ùˆ Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù† Ø¯Ø§Ù„Ø© Ø¨ØªØªØ®Ø²Ù† ÙƒÙ€ Ù‚ÙŠÙ…Ø© ÙÙŠ Ù…ØªØºÙŠØ±. Ù…Ù…ÙƒÙ† ØªÙƒÙˆÙ† **anonymous** Ø£Ùˆ **named**. Ø§Ù„Ù€ named function expressions Ù…ÙÙŠØ¯Ø© Ù„Ù„ØªÙƒØ±Ø§Ø± (recursion) Ø£Ùˆ Ø§Ù„Ù€ debugging. ÙˆØ¹Ù„Ù‰ Ø¹ÙƒØ³ Ø§Ù„Ù€ function declarationsØŒ Ø§Ù„Ù€ function expressions Ù…Ø´ Ø¨ÙŠØ­ØµÙ„ Ù„Ù‡Ø§ **hoisting**ØŒ ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù…ÙŠÙ†ÙØ¹Ø´ ØªØ³ØªØ¯Ø¹ÙŠÙ‡Ø§ Ù‚Ø¨Ù„ ØªØ¹Ø±ÙŠÙÙ‡Ø§.\n\nÙ…Ø«Ø§Ù„:\n\n```js\nsayHello(); // âŒ Error: Cannot access 'sayHello' before initialization\n\nconst sayHello = function() {\n  console.log(\"Hello from a function expression!\");\n};\n```\n\nğŸ‘‰ **Ø§Ù„Ø§Ø®ØªÙ„Ø§ÙØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**\n\n* **Hoisting:** Ø§Ù„Ù€ function declarations Ø¨ÙŠØ­ØµÙ„ Ù„Ù‡Ø§ hoisting Ù„ÙƒÙ† Ø§Ù„Ù€ function expressions Ù„Ø£.\n* **Readability:** Ø§Ù„Ù€ declarations Ø¨ØªØ®Ù„ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø£ÙˆØ¶Ø­ Ø®ØµÙˆØµÙ‹Ø§ Ù„Ù…Ø§ ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¯ÙˆØ§Ù„ ÙÙŠ Ø£ÙƒØªØ± Ù…Ù† Ù…ÙƒØ§Ù†.\n* **Flexibility:** Ø§Ù„Ù€ expressions Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø© Ù„Ø£Ù†Ù‡Ø§ Ù…Ù…ÙƒÙ† ØªØªØ®Ø²Ù† ÙƒÙ€ callback Ø£Ùˆ Ø¬ÙˆØ§ data structure.\n\n",
      "hints": {
        "en": [],
        "ar": []
      },
      "codeSnippetAnswer": {
        "code": "",
        "lang": "javascript"
      }
    },
    "evaluation": {
      "points": 5,
      "timeEstimate": ""
    },
    "interaction": {
      "testYourself": true,
      "showAnswer": true,
      "markAsMemorized": true
    },
    "metadata": {
      "author": "Mohamed Sayed",
      "createdAt": "2025-10-01T20:00:00Z",
      "updatedAt": "2025-10-01T20:00:00Z",
      "references": [
        ""
      ]
    }
  },
  {
    "id": "2",
    "type": {
      "en": "theoretical",
      "ar": "Ù†Ø¸Ø±ÙŠ"
    },
    "difficulty": {
      "en": "easy",
      "ar": "Ø³Ù‡Ù„"
    },
    "categories": [
      {
        "en": "JavaScript",
        "ar": "JavaScript"
      }
    ],
    "tags": [
      {
        "en": "closure, JavaScript",
        "ar": "closure, JavaScript"
      }
    ],
    "question": {
      "en": "What is a closure in JavaScript?",
      "ar": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ù€ closure ÙÙŠ JavaScriptØŸ"
    },
    "codeSnippetQuestion": {
      "code": "",
      "lang": ""
    },
    "examples": [],
    "media": {
      "image": "",
      "video": "",
      "audio": ""
    },
    "optionsForMcq": [
      {
        "id": "",
        "text": {
          "en": "",
          "ar": ""
        },
        "isCorrect": false,
        "feedback": {
          "en": "",
          "ar": ""
        }
      }
    ],
    "answer": {
      "en": "\n\n**Answer:**\n\nA **closure** in JavaScript is a **combination of a function and the lexical environment in which that function was declared**.  \nIn simpler terms, a closure allows a function to **remember and access variables from its outer (enclosing) scope**, even after that outer function has finished executing.\n\n---\n\n### **Understanding Lexical Environment**\n\nIn JavaScript, thereâ€™s something called a **lexical environment**, and thatâ€™s the **reason closures exist** and work the way they do.\n\nA **lexical environment** is an **internal object created by the JavaScript engine** whenever a **function or block** is executed.  \nThis object **stores all the variables and functions** that belong to that particular **scope** â€” whether itâ€™s a function scope or block scope.\n\nNow, when we **create an inner function inside another function**, a **new lexical environment** is created for the inner one.  \nBut hereâ€™s the key point:\n\n> The new inner lexical environment **keeps a reference** (not a copy) to the **outer lexical environment** where it was defined.\n\nThat means the inner function can still **access the variables** of its parent function â€” even after the parent function has finished executing.\n\n---\n\n### **Example: Basic Closure**\n\n```javascript\nfunction outer() {\n  let count = 0;\n\n  function inner() {\n    count++;\n    console.log(count);\n  }\n\n  return inner;\n}\n\nconst counter = outer();\ncounter(); // 1\ncounter(); // 2\n```\n\n---\n\n### **Step-by-Step Explanation**\n\n1. When `outer()` runs, a **lexical environment** is created that contains `{ count: 0 }`.\n2. The `inner()` function is created **inside** that environment, so it gets a **reference** to it.\n3. When `outer()` returns `inner`, we still have access to that same lexical environment â€” even though `outer()` has finished execution.\n4. Each time `counter()` is called, it accesses and updates the `count` variable inside that preserved environment.\n\nThat relationship â€” where a function â€œremembersâ€ the variables from the scope it was created in â€” is exactly what we call a **closure**.\n\n---\n\n### **So now we can say that:**\n\nA **closure** in JavaScript is **a combination of a function and the lexical environment in which that function was declared**.  \nIn simpler terms, a closure allows a function to **remember and access variables from its outer scope**, even after that outer function has finished executing.\n\n---\n\n### **Key Takeaways**\n\n* Every function or block creates its own **lexical environment**.  \n* Inner functions **keep references** to their parent environments.  \n* The **chain of environments** forms the **closure** mechanism.  \n* Closures enable you to:\n  * Keep data **private**\n  * Maintain **state** between function calls\n  * Write **modular** and **encapsulated** code\n\n---",
      "ar": "\n\n**Ø§Ù„Ø§Ø¬Ø§Ø¨Ø©:**\n\nA **Closure** ÙÙŠ JavaScript Ù‡Ùˆ **Ù…Ø²ÙŠØ¬ Ù…Ù† function ÙˆØ§Ù„Ù€ lexical environment** Ø§Ù„Ù„ÙŠ Ø§ØªØ¹Ø±ÙØª ÙÙŠÙ‡Ø§ Ø§Ù„Ù€ function Ø¯ÙŠ.  \nØ¨Ø¨Ø³Ø§Ø·Ø©ØŒ Ø§Ù„Ù€ closure Ø¨ÙŠØ³Ù…Ø­ Ù„Ù„Ù€ function Ø¥Ù†Ù‡Ø§ **ØªÙØªÙƒØ± ÙˆØªÙˆØµÙ„ Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª** Ø§Ù„Ù„ÙŠ ÙÙŠ Ø§Ù„Ù€ **outer scope** Ø¨ØªØ§Ø¹Ù‡Ø§ Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ù…Ø§ Ø§Ù„Ù€ function Ø§Ù„Ø£Ø¨ Ø®Ù„ØµØª ØªÙ†ÙÙŠØ°Ù‡Ø§.\n\n---\n\n### **ÙÙ‡Ù… Ø§Ù„Ù€ Lexical Environment**\n\nÙÙŠ JavaScript ÙÙŠ Ø­Ø§Ø¬Ø© Ø§Ø³Ù…Ù‡Ø§ **lexical environment**ØŒ ÙˆØ¯ÙŠ Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ®Ù„ÙŠ Ø§Ù„Ù€ closure Ù…ÙˆØ¬ÙˆØ¯ ÙˆÙŠØ´ØªØºÙ„ Ø¨Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø¯ÙŠ.\n\nØ§Ù„Ù€ **lexical environment** Ù‡Ùˆ **object Ø¯Ø§Ø®Ù„ÙŠ Ø¨ÙŠØ¹Ù…Ù„Ù‡ Ø§Ù„Ù€ JavaScript engine** ÙƒÙ„ Ù…Ø±Ø© **function Ø£Ùˆ block** Ø¨ÙŠØªÙ†ÙØ°.  \nØ§Ù„Ù€ object Ø¯Ù‡ Ø¨ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ **ÙƒÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ÙˆØ§Ù„Ù€ functions** Ø§Ù„Ù„ÙŠ Ø¨ØªØ®Øµ Ø§Ù„Ù€ **scope** Ø¯Ù‡ â€” Ø³ÙˆØ§Ø¡ ÙƒØ§Ù† function scope Ø£Ùˆ block scope.\n\nÙ„Ù…Ø§ Ø¨Ù†Ø¹Ù…Ù„ **inner function Ø¬ÙˆÙ‡ function ØªØ§Ù†ÙŠØ©**ØŒ Ø¨ÙŠØªØ®Ù„Ù‚ **lexical environment Ø¬Ø¯ÙŠØ¯** Ù„Ù„Ù€ inner function.  \nØ¨Ø³ Ø§Ù„Ù…Ù‡Ù… Ù‡Ù†Ø§:\n\n> Ø§Ù„Ù€ inner lexical environment **Ø¨ÙŠØ­ØªÙØ¸ Ø¨Ù€ reference** (Ù…Ø´ Ù†Ø³Ø®Ø©) Ù„Ù„Ù€ **outer lexical environment** Ø§Ù„Ù„ÙŠ Ø§ØªØ¹Ø±Ù ÙÙŠÙ‡.\n\nÙˆØ¯Ù‡ Ù…Ø¹Ù†Ø§Ù‡ Ø¥Ù† Ø§Ù„Ù€ inner function ØªÙ‚Ø¯Ø± **ØªÙˆØµÙ„ Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª** Ø¨ØªØ§Ø¹Ø© Ø§Ù„Ù€ parent function Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ù…Ø§ Ø§Ù„Ù€ parent Ø®Ù„ØµØª.\n\n---\n\n### **Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ Closure**\n\n```javascript\nfunction outer() {\n  let count = 0;\n\n  function inner() {\n    count++;\n    console.log(count);\n  }\n\n  return inner;\n}\n\nconst counter = outer();\ncounter(); // 1\ncounter(); // 2\n```\n\n---\n\n### **Ø§Ù„Ø´Ø±Ø­ Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©**\n\n1. Ù„Ù…Ø§ `outer()` Ø¨ØªØ´ØªØºÙ„ØŒ Ø¨ÙŠØªØ®Ù„Ù‚ **lexical environment** ÙÙŠÙ‡ `{ count: 0 }`.\n2. Ø§Ù„Ù€ `inner()` function Ø¨ØªØªØ®Ù„Ù‚ **Ø¬ÙˆÙ‡** Ø§Ù„Ø¨ÙŠØ¦Ø© Ø¯ÙŠØŒ ÙØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ø¨ØªØ§Ø®Ø¯ **reference** Ù„ÙŠÙ‡Ø§.\n3. Ù„Ù…Ø§ `outer()` Ø¨ØªØ±Ø¬Ø¹ `inner`ØŒ Ø¥Ø­Ù†Ø§ Ù„Ø³Ù‡ Ø¹Ù†Ø¯Ù†Ø§ ÙˆØµÙˆÙ„ Ù„Ù†ÙØ³ Ø§Ù„Ù€ environment Ø¯ÙŠ â€” Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ù…Ø§ `outer()` Ø®Ù„ØµØª.\n4. ÙƒÙ„ Ù…Ø±Ø© `counter()` Ø¨ØªØªØ³ØªØ¯Ø¹Ù‰ØŒ Ø¨ØªØ¹Ø¯Ù„ ÙˆØªØ³ØªØ®Ø¯Ù… Ù†ÙØ³ Ø§Ù„Ù…ØªØºÙŠØ± `count` Ø§Ù„Ù„ÙŠ Ù…Ø­ÙÙˆØ¸ ÙÙŠ Ø§Ù„Ø¨ÙŠØ¦Ø© Ø¯ÙŠ.\n\nØ§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¯ÙŠ â€” Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡Ø§ function Ø¨ØªÙØªÙƒØ± Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„ÙŠ ÙƒØ§Ù†Øª ÙÙŠ Ø§Ù„Ù€ scope Ø§Ù„Ù„ÙŠ Ø§ØªØ®Ù„Ù‚Øª ÙÙŠÙ‡ â€” Ù‡ÙŠ Ø¨Ø§Ù„Ø¸Ø¨Ø· Ø§Ù„Ù„ÙŠ Ø¨Ù†Ø³Ù…ÙŠÙ‡Ø§ **closure**.\n\n---\n\n### **Ù†Ù‚Ø¯Ø± Ù†Ù‚ÙˆÙ„ Ø¥Ù†:**\n\nØ§Ù„Ù€ **closure** ÙÙŠ JavaScript Ù‡Ùˆ **Ù…Ø²ÙŠØ¬ Ù…Ù† function ÙˆØ§Ù„Ù€ lexical environment Ø§Ù„Ù„ÙŠ Ø§ØªØ¹Ø±ÙØª ÙÙŠÙ‡Ø§**.  \nØ¨Ø¨Ø³Ø§Ø·Ø©ØŒ Ø§Ù„Ù€ closure Ø¨ÙŠØ³Ù…Ø­ Ù„Ù„Ù€ function Ø¥Ù†Ù‡Ø§ **ØªÙØªÙƒØ± ÙˆØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©** Ø­ØªÙ‰ Ø¨Ø¹Ø¯ Ù…Ø§ Ø§Ù„Ù€ parent function ØªØ®Ù„Øµ.\n\n---\n\n### **Ø£Ù‡Ù… Ø§Ù„Ù†Ù‚Ø§Ø·**\n\n* ÙƒÙ„ function Ø£Ùˆ block Ø¨ÙŠØ®Ù„Ù‚ **lexical environment** Ø®Ø§Øµ Ø¨ÙŠÙ‡.  \n* Ø§Ù„Ù€ inner functions **Ø¨ØªØ­ØªÙØ¸ Ø¨Ù€ references** Ù„Ù„Ù€ parent environments.  \n* Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø¯ÙŠ Ù…Ù† Ø§Ù„Ù€ environments Ù‡ÙŠ Ø§Ù„Ù„ÙŠ Ø¨ØªÙƒÙˆÙ‘Ù† **Ø§Ù„Ù€ closure mechanism**.  \n* Ø§Ù„Ù€ closure Ø¨ÙŠØ³Ø§Ø¹Ø¯Ùƒ ÙÙŠ:\n  * ØªØ®Ù„ÙŠ Ø§Ù„Ø¯Ø§ØªØ§ **private**\n  * ØªØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ **state** Ø¨ÙŠÙ† Ø§Ù„Ù€ function calls\n  * ØªÙƒØªØ¨ ÙƒÙˆØ¯ **modular** Ùˆ **Ù…Ù†Ø¸Ù… Ø£ÙƒØªØ±**\n\n---",
      "hints": {
        "en": [],
        "ar": []
      },
      "codeSnippetAnswer": {
        "code": " ",
        "lang": ""
      }
    },
    "evaluation": {
      "points": 5,
      "timeEstimate": ""
    },
    "interaction": {
      "testYourself": true,
      "showAnswer": true,
      "markAsMemorized": true
    },
    "metadata": {
      "author": "Mohamed Sayed",
      "createdAt": "2025-10-01T20:00:00Z",
      "updatedAt": "2025-10-01T20:00:00Z",
      "references": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
      ]
    }
  },
  {
    "id": "3",
    "type": {
      "en": "theoretical",
      "ar": "Ù†Ø¸Ø±ÙŠ"
    },
    "difficulty": {
      "en": "easy",
      "ar": "Ø³Ù‡Ù„"
    },
    "categories": [
      {
        "en": "JavaScript",
        "ar": "Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª"
      }
    ],
    "tags": [
      {
        "en": "arrow function, JavaScript",
        "ar": "arrow function, Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª"
      }
    ],
    "question": {
      "en": "What is the Arrow Function? What are its advantages and disadvantages?",
      "ar": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ù€ Arrow FunctionØŸ ÙˆÙ…Ø§ Ù‡ÙŠ Ù…Ù…ÙŠØ²Ø§ØªÙ‡ ÙˆØ¹ÙŠÙˆØ¨Ù‡ØŸ"
    },
    "codeSnippetQuestion": {"code": "", "lang": ""},
    "examples": [],
    "media": {
      "image": "",
      "video": "",
      "audio": ""
    },
    "optionsForMcq": [
      {
        "id": "",
        "text": {
          "en": "",
          "ar": ""
        },
        "isCorrect": false,
        "feedback": {
          "en": "",
          "ar": ""
        }
      }
    ],
    "answer": {
      "en": "",
      "ar": "",
      "hints": {
        "en": [],
        "ar": []
      },
      "codeSnippetAnswer": {"code": "", "lang": ""}
    },
    "evaluation": {
      "points": 5,
      "timeEstimate": ""
    },
    "interaction": {
      "testYourself": true,
      "showAnswer": true,
      "markAsMemorized": true
    },
    "metadata": {
      "author": "",
      "createdAt": "",
      "updatedAt": "",
      "references": [
        ""
      ]
    }
  }
]

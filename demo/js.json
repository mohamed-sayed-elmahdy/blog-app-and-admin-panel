[
  {
    "id": "1",
    "type": {
      "en": "theoretical",
      "ar": "Ù†Ø¸Ø±ÙŠ"
    },
    "difficulty": {
      "en": "easy",
      "ar": "Ø³Ù‡Ù„"
    },
    "categories": [
      {
        "en": "JavaScript",
        "ar": "Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª"
      }
    ],
    "tags": [
      {
        "en": "function declaration, function expression",
        "ar": "function declaration, function expression"
      }
    ],
    "question": {
      "en": "What is the difference between function declaration and function expression?",
      "ar": "Ù…Ø§ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† function declaration Ùˆ function expressionØŸ"
    },
    "codeSnippetQuestion": {
      "code": "",
      "lang": "javascript"
    },
    "examples": [],
    "media": {
      "image": "",
      "video": "",
      "audio": ""
    },
    "optionsForMcq": [
      {
        "id": "",
        "text": {
          "en": "",
          "ar": ""
        },
        "isCorrect": false,
        "feedback": {
          "en": "",
          "ar": ""
        }
      }
    ],
    "answer": {
      "en": "\n\n**Answer:**\n\nA **function declaration** is a function defined using the `function` keyword followed by its name. A function declaration can be called even before it appears in its scope because it is **hoisted**.\n\nExample:\n\n```js\nsayHello(); // âœ… works, because of hoisting\n\nfunction sayHello() {\n  console.log(\"Hello from a function declaration!\");\n}\n```\n\nA **function expression**, on the other hand, is a function assigned as a value to a variable. It can be **anonymous** or **named**. Named function expressions are useful for recursion or debugging. Unlike function declarations, function expressions are **not hoisted**, so they cannot be called before they are defined.\n\nExample:\n\n```js\nsayHello(); // âŒ Error: Cannot access 'sayHello' before initialization\n\nconst sayHello = function() {\n  console.log(\"Hello from a function expression!\");\n};\n```\n\nğŸ‘‰ **Key differences:**\n\n* **Hoisting:** Function declarations are hoisted, function expressions are not.\n* **Readability:** Declarations make code more structured when functions are used in multiple places.\n* **Flexibility:** Expressions are more flexible since they can be passed as arguments (e.g., callbacks) or stored in data structures.\n\n",
      "ar": "\n\n**Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©:**\n\nØ§Ù„Ù€ **function declaration** Ù‡Ùˆ ØªØ¹Ø±ÙŠÙ Ø¯Ø§Ù„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒÙ„Ù…Ø© `function` Ù…ØªØ¨ÙˆØ¹ Ø¨Ø§Ø³Ù…Ù‡Ø§. Ø§Ù„Ù€ function declaration Ù…Ù…ÙƒÙ† ØªØ³ØªØ¯Ø¹ÙŠÙ‡ Ø­ØªÙ‰ Ù‚Ø¨Ù„ Ù…Ø§ ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ù€ scope Ø¨ØªØ§Ø¹Ù‡ Ù„Ø£Ù†Ù‡ Ø¨ÙŠØªÙ… **hoisting**.\n\nÙ…Ø«Ø§Ù„:\n\n```js\nsayHello(); // âœ… Ø´ØºØ§Ù„ Ø¨Ø³Ø¨Ø¨ hoisting\n\nfunction sayHello() {\n  console.log(\"Hello from a function declaration!\");\n}\n```\n\nØ£Ù…Ø§ Ø§Ù„Ù€ **function expression** ÙÙ‡Ùˆ Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù† Ø¯Ø§Ù„Ø© Ø¨ØªØªØ®Ø²Ù† ÙƒÙ€ Ù‚ÙŠÙ…Ø© ÙÙŠ Ù…ØªØºÙŠØ±. Ù…Ù…ÙƒÙ† ØªÙƒÙˆÙ† **anonymous** Ø£Ùˆ **named**. Ø§Ù„Ù€ named function expressions Ù…ÙÙŠØ¯Ø© Ù„Ù„ØªÙƒØ±Ø§Ø± (recursion) Ø£Ùˆ Ø§Ù„Ù€ debugging. ÙˆØ¹Ù„Ù‰ Ø¹ÙƒØ³ Ø§Ù„Ù€ function declarationsØŒ Ø§Ù„Ù€ function expressions Ù…Ø´ Ø¨ÙŠØ­ØµÙ„ Ù„Ù‡Ø§ **hoisting**ØŒ ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù…ÙŠÙ†ÙØ¹Ø´ ØªØ³ØªØ¯Ø¹ÙŠÙ‡Ø§ Ù‚Ø¨Ù„ ØªØ¹Ø±ÙŠÙÙ‡Ø§.\n\nÙ…Ø«Ø§Ù„:\n\n```js\nsayHello(); // âŒ Error: Cannot access 'sayHello' before initialization\n\nconst sayHello = function() {\n  console.log(\"Hello from a function expression!\");\n};\n```\n\nğŸ‘‰ **Ø§Ù„Ø§Ø®ØªÙ„Ø§ÙØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**\n\n* **Hoisting:** Ø§Ù„Ù€ function declarations Ø¨ÙŠØ­ØµÙ„ Ù„Ù‡Ø§ hoisting Ù„ÙƒÙ† Ø§Ù„Ù€ function expressions Ù„Ø£.\n* **Readability:** Ø§Ù„Ù€ declarations Ø¨ØªØ®Ù„ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø£ÙˆØ¶Ø­ Ø®ØµÙˆØµÙ‹Ø§ Ù„Ù…Ø§ ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¯ÙˆØ§Ù„ ÙÙŠ Ø£ÙƒØªØ± Ù…Ù† Ù…ÙƒØ§Ù†.\n* **Flexibility:** Ø§Ù„Ù€ expressions Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø© Ù„Ø£Ù†Ù‡Ø§ Ù…Ù…ÙƒÙ† ØªØªØ®Ø²Ù† ÙƒÙ€ callback Ø£Ùˆ Ø¬ÙˆØ§ data structure.\n\n",
      "hints": {
        "en": [],
        "ar": []
      },
      "codeSnippetAnswer": {
        "code": "",
        "lang": "javascript"
      }
    },
    "evaluation": {
      "points": 5,
      "timeEstimate": ""
    },
    "interaction": {
      "testYourself": true,
      "showAnswer": true,
      "markAsMemorized": true
    },
    "metadata": {
      "author": "Mohamed Sayed",
      "createdAt": "2025-10-01T20:00:00Z",
      "updatedAt": "2025-10-01T20:00:00Z",
      "references": [
        ""
      ]
    }
  },
  {
    "id": "2",
    "type": {
      "en": "theoretical",
      "ar": "Ù†Ø¸Ø±ÙŠ"
    },
    "difficulty": {
      "en": "easy",
      "ar": "Ø³Ù‡Ù„"
    },
    "categories": [
      {
        "en": "JavaScript",
        "ar": "JavaScript"
      }
    ],
    "tags": [
      {
        "en": "closure, JavaScript",
        "ar": "closure, JavaScript"
      }
    ],
    "question": {
      "en": "What is a closure in JavaScript?",
      "ar": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ù€ closure ÙÙŠ JavaScriptØŸ"
    },
    "codeSnippetQuestion": {
      "code": "",
      "lang": ""
    },
    "examples": [],
    "media": {
      "image": "",
      "video": "",
      "audio": ""
    },
    "optionsForMcq": [
      {
        "id": "",
        "text": {
          "en": "",
          "ar": ""
        },
        "isCorrect": false,
        "feedback": {
          "en": "",
          "ar": ""
        }
      }
    ],
    "answer": {
  "en": "\n\n**Answer:**\n\nA **closure** in JavaScript is a combination of a **function** and the **lexical environment** in which that function was declared.\n\nIn simpler terms, it allows a function to **remember and access variables from its outer scope**, even after that outer function has finished executing.\n\n<br>\n\n---\n\n## ğŸ§© **What is a Lexical Environment?**\n\nA **lexical environment** is an internal object created by the JavaScript engine whenever a **function or block** is executed. It **stores variables and functions** that belong to that particular scope.\n\n<br>\n\nWhen an **inner function** is created inside another function, the inner one keeps a **reference** (not a copy) to the **outer environment** where it was defined.\n\nThis is why the inner function can still access variables from its parent, even after the parent function is done executing.\n\n<br>\n\n ## ğŸ’¡ **Example: Basic Closure**\n```js\nfunction outer() {\n  let count = 0;\n\n  function inner() {\n    count++;\n    console.log(count);\n  }\n\n  return inner;\n}\n\nconst counter = outer();\ncounter(); // 1\ncounter(); // 2\n```\n\n### **â¤ Step By Step Explanation:**\n\n**1-** When `outer()` runs, it creates a **lexical environment** containing `{ count: 0 }`.\n\n**2-** The `inner()` function is defined inside that environment and keeps a **reference** to it.\n\n**3-** When `outer()` finishes, we still have access to that environment via the returned `inner` function.\n\n**4-** Each call to `counter()` updates and logs the same `count` variable.\n\n<br>ğŸ§  **Definition Recap:**\n\nA **closure** = **function + remembered lexical environment**.\n\n<br>â˜‘ï¸ Closures help you:\n  * 1- Keep data **private**.\n  * 2- Maintain **state** across function calls.\n  * 3- Write **modular**, **encapsulated** code.\n\n<br>ğŸ”‘ **Key Takeaways:**\n\n* â— Every function or block creates its own **lexical environment**.\n* â— Inner functions **keep references** to their parent's lexical environment.\n* â— The chain of lexical environments forms a **closure**.\n\n<br>\n\nğŸ§° Real-world Example:\n\nClosures are commonly used to create private variables in JavaScript.\n```js\nfunction createCounter() {\n  let count = 0; // private variable\n\n  return {\n    increment: function() { count++; console.log(count); },\n    reset: function() { count = 0; console.log(\"Reset!\"); }\n  };\n}\n\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.reset();     // Reset!\n```\n ğŸ§© In short:\nA closure lets a function remember and access variables from its outer scope, even after that scope has finished executing.\n\n",
      
      "codeSnippetAnswer": {
        "code": " ",
        "lang": ""
      }
    },
    "evaluation": {
      "points": 5,
      "timeEstimate": ""
    },
    "interaction": {
      "testYourself": true,
      "showAnswer": true,
      "markAsMemorized": true
    },
    "metadata": {
      "author": "Mohamed Sayed",
      "createdAt": "2025-10-01T20:00:00Z",
      "updatedAt": "2025-10-01T20:00:00Z",
      "references": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
      ]
    }
  },
  {
    "id": "3",
    "type": {
      "en": "theoretical",
      "ar": "Ù†Ø¸Ø±ÙŠ"
    },
    "difficulty": {
      "en": "easy",
      "ar": "Ø³Ù‡Ù„"
    },
    "categories": [
      {
        "en": "JavaScript",
        "ar": "Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª"
      }
    ],
    "tags": [
      {
        "en": "arrow function, JavaScript",
        "ar": "arrow function, Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª"
      }
    ],
    "question": {
      "en": "What is the Arrow Function? What are its advantages and disadvantages?",
      "ar": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ù€ Arrow FunctionØŸ ÙˆÙ…Ø§ Ù‡ÙŠ Ù…Ù…ÙŠØ²Ø§ØªÙ‡ ÙˆØ¹ÙŠÙˆØ¨Ù‡ØŸ"
    },
    "codeSnippetQuestion": {"code": "", "lang": ""},
    "examples": [],
    "media": {
      "image": "",
      "video": "",
      "audio": ""
    },
    "optionsForMcq": [
      {
        "id": "",
        "text": {
          "en": "",
          "ar": ""
        },
        "isCorrect": false,
        "feedback": {
          "en": "",
          "ar": ""
        }
      }
    ],
    "answer": {
      "en": "",
      "ar": "",
      "hints": {
        "en": [],
        "ar": []
      },
      "codeSnippetAnswer": {"code": "", "lang": ""}
    },
    "evaluation": {
      "points": 5,
      "timeEstimate": ""
    },
    "interaction": {
      "testYourself": true,
      "showAnswer": true,
      "markAsMemorized": true
    },
    "metadata": {
      "author": "",
      "createdAt": "",
      "updatedAt": "",
      "references": [
        ""
      ]
    }
  }
]


